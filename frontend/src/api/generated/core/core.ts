/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Student Evaluation System API
 * Outcome-based assessment system for academic programs
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from 'react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from 'react-query';

import type {
  CoreCoursesListParams,
  CoreDegreeLevelsListParams,
  CoreDepartmentsListParams,
  CoreLearningOutcome,
  CoreLearningOutcomesListParams,
  CoreLoPoMappingsListParams,
  CoreProgramsListParams,
  CoreStudentLoScoresListParams,
  CoreStudentPoScoresListParams,
  CoreStudentsListParams,
  CoreTermsListParams,
  Course,
  DegreeLevel,
  Department,
  LearningOutcomeProgramOutcomeMapping,
  PaginatedCoreLearningOutcomeList,
  PaginatedCourseList,
  PaginatedDegreeLevelList,
  PaginatedDepartmentList,
  PaginatedLearningOutcomeProgramOutcomeMappingList,
  PaginatedProgramList,
  PaginatedStudentLearningOutcomeScoreList,
  PaginatedStudentProfileList,
  PaginatedStudentProgramOutcomeScoreList,
  PaginatedTermList,
  PatchedCoreLearningOutcome,
  PatchedCourse,
  PatchedDegreeLevel,
  PatchedDepartment,
  PatchedLearningOutcomeProgramOutcomeMapping,
  PatchedProgram,
  PatchedTerm,
  Program,
  StudentLearningOutcomeScore,
  StudentProfile,
  StudentProgramOutcomeScore,
  Term
} from '../../model';

import { customInstance } from '../../mutator';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * CRUD operations for courses.
 */
export const coreCoursesList = (
    params?: CoreCoursesListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedCourseList>(
      {url: `/api/core/courses/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreCoursesListInfiniteQueryKey = (params?: CoreCoursesListParams,) => {
    return [
    'infinate', `/api/core/courses/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreCoursesListQueryKey = (params?: CoreCoursesListParams,) => {
    return [
    `/api/core/courses/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreCoursesListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreCoursesList>>, TError = unknown>(params?: CoreCoursesListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreCoursesList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreCoursesListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreCoursesList>>> = ({ signal, pageParam }) => coreCoursesList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreCoursesList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreCoursesListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreCoursesList>>>
export type CoreCoursesListInfiniteQueryError = unknown



export function useCoreCoursesListInfinite<TData = Awaited<ReturnType<typeof coreCoursesList>>, TError = unknown>(
 params?: CoreCoursesListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreCoursesList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreCoursesListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreCoursesListQueryOptions = <TData = Awaited<ReturnType<typeof coreCoursesList>>, TError = unknown>(params?: CoreCoursesListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreCoursesList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreCoursesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreCoursesList>>> = ({ signal }) => coreCoursesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreCoursesList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreCoursesListQueryResult = NonNullable<Awaited<ReturnType<typeof coreCoursesList>>>
export type CoreCoursesListQueryError = unknown



export function useCoreCoursesList<TData = Awaited<ReturnType<typeof coreCoursesList>>, TError = unknown>(
 params?: CoreCoursesListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreCoursesList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreCoursesListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for courses.
 */
export const coreCoursesCreate = (
    course: NonReadonly<Course>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Course>(
      {url: `/api/core/courses/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: course, signal
    },
      options);
    }
  


export const getCoreCoursesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreCoursesCreate>>, TError,{data: NonReadonly<Course>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreCoursesCreate>>, TError,{data: NonReadonly<Course>}, TContext> => {

const mutationKey = ['coreCoursesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreCoursesCreate>>, {data: NonReadonly<Course>}> = (props) => {
          const {data} = props ?? {};

          return  coreCoursesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreCoursesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof coreCoursesCreate>>>
    export type CoreCoursesCreateMutationBody = NonReadonly<Course>
    export type CoreCoursesCreateMutationError = unknown

    export const useCoreCoursesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreCoursesCreate>>, TError,{data: NonReadonly<Course>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreCoursesCreate>>,
        TError,
        {data: NonReadonly<Course>},
        TContext
      > => {

      const mutationOptions = getCoreCoursesCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for courses.
 */
export const coreCoursesRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Course>(
      {url: `/api/core/courses/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreCoursesRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/courses/${id}/`
    ] as const;
    }

export const getCoreCoursesRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/courses/${id}/`
    ] as const;
    }

    
export const getCoreCoursesRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreCoursesRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreCoursesRetrieve>>> = ({ signal }) => coreCoursesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreCoursesRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreCoursesRetrieve>>>
export type CoreCoursesRetrieveInfiniteQueryError = unknown



export function useCoreCoursesRetrieveInfinite<TData = Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreCoursesRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreCoursesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreCoursesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreCoursesRetrieve>>> = ({ signal }) => coreCoursesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreCoursesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreCoursesRetrieve>>>
export type CoreCoursesRetrieveQueryError = unknown



export function useCoreCoursesRetrieve<TData = Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreCoursesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreCoursesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for courses.
 */
export const coreCoursesUpdate = (
    id: number,
    course: NonReadonly<Course>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Course>(
      {url: `/api/core/courses/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: course
    },
      options);
    }
  


export const getCoreCoursesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreCoursesUpdate>>, TError,{id: number;data: NonReadonly<Course>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreCoursesUpdate>>, TError,{id: number;data: NonReadonly<Course>}, TContext> => {

const mutationKey = ['coreCoursesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreCoursesUpdate>>, {id: number;data: NonReadonly<Course>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreCoursesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreCoursesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreCoursesUpdate>>>
    export type CoreCoursesUpdateMutationBody = NonReadonly<Course>
    export type CoreCoursesUpdateMutationError = unknown

    export const useCoreCoursesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreCoursesUpdate>>, TError,{id: number;data: NonReadonly<Course>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreCoursesUpdate>>,
        TError,
        {id: number;data: NonReadonly<Course>},
        TContext
      > => {

      const mutationOptions = getCoreCoursesUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for courses.
 */
export const coreCoursesPartialUpdate = (
    id: number,
    patchedCourse: NonReadonly<PatchedCourse>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Course>(
      {url: `/api/core/courses/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCourse
    },
      options);
    }
  


export const getCoreCoursesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreCoursesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedCourse>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreCoursesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedCourse>}, TContext> => {

const mutationKey = ['coreCoursesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreCoursesPartialUpdate>>, {id: number;data: NonReadonly<PatchedCourse>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreCoursesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreCoursesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreCoursesPartialUpdate>>>
    export type CoreCoursesPartialUpdateMutationBody = NonReadonly<PatchedCourse>
    export type CoreCoursesPartialUpdateMutationError = unknown

    export const useCoreCoursesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreCoursesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedCourse>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreCoursesPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedCourse>},
        TContext
      > => {

      const mutationOptions = getCoreCoursesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for courses.
 */
export const coreCoursesDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/core/courses/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getCoreCoursesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreCoursesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreCoursesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['coreCoursesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreCoursesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  coreCoursesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreCoursesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof coreCoursesDestroy>>>
    
    export type CoreCoursesDestroyMutationError = unknown

    export const useCoreCoursesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreCoursesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreCoursesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCoreCoursesDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get all learning outcomes for this course.
 */
export const coreCoursesLearningOutcomesRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Course>(
      {url: `/api/core/courses/${id}/learning_outcomes/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreCoursesLearningOutcomesRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/courses/${id}/learning_outcomes/`
    ] as const;
    }

export const getCoreCoursesLearningOutcomesRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/courses/${id}/learning_outcomes/`
    ] as const;
    }

    
export const getCoreCoursesLearningOutcomesRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreCoursesLearningOutcomesRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>> = ({ signal }) => coreCoursesLearningOutcomesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreCoursesLearningOutcomesRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>>
export type CoreCoursesLearningOutcomesRetrieveInfiniteQueryError = unknown



export function useCoreCoursesLearningOutcomesRetrieveInfinite<TData = Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreCoursesLearningOutcomesRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreCoursesLearningOutcomesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreCoursesLearningOutcomesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>> = ({ signal }) => coreCoursesLearningOutcomesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreCoursesLearningOutcomesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>>
export type CoreCoursesLearningOutcomesRetrieveQueryError = unknown



export function useCoreCoursesLearningOutcomesRetrieve<TData = Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreCoursesLearningOutcomesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreCoursesLearningOutcomesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for degree levels.
 */
export const coreDegreeLevelsList = (
    params?: CoreDegreeLevelsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedDegreeLevelList>(
      {url: `/api/core/degree-levels/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreDegreeLevelsListInfiniteQueryKey = (params?: CoreDegreeLevelsListParams,) => {
    return [
    'infinate', `/api/core/degree-levels/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreDegreeLevelsListQueryKey = (params?: CoreDegreeLevelsListParams,) => {
    return [
    `/api/core/degree-levels/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreDegreeLevelsListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError = unknown>(params?: CoreDegreeLevelsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreDegreeLevelsListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreDegreeLevelsList>>> = ({ signal, pageParam }) => coreDegreeLevelsList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreDegreeLevelsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreDegreeLevelsList>>>
export type CoreDegreeLevelsListInfiniteQueryError = unknown



export function useCoreDegreeLevelsListInfinite<TData = Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError = unknown>(
 params?: CoreDegreeLevelsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreDegreeLevelsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreDegreeLevelsListQueryOptions = <TData = Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError = unknown>(params?: CoreDegreeLevelsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreDegreeLevelsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreDegreeLevelsList>>> = ({ signal }) => coreDegreeLevelsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreDegreeLevelsListQueryResult = NonNullable<Awaited<ReturnType<typeof coreDegreeLevelsList>>>
export type CoreDegreeLevelsListQueryError = unknown



export function useCoreDegreeLevelsList<TData = Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError = unknown>(
 params?: CoreDegreeLevelsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreDegreeLevelsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for degree levels.
 */
export const coreDegreeLevelsCreate = (
    degreeLevel: NonReadonly<DegreeLevel>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DegreeLevel>(
      {url: `/api/core/degree-levels/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: degreeLevel, signal
    },
      options);
    }
  


export const getCoreDegreeLevelsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsCreate>>, TError,{data: NonReadonly<DegreeLevel>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsCreate>>, TError,{data: NonReadonly<DegreeLevel>}, TContext> => {

const mutationKey = ['coreDegreeLevelsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreDegreeLevelsCreate>>, {data: NonReadonly<DegreeLevel>}> = (props) => {
          const {data} = props ?? {};

          return  coreDegreeLevelsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreDegreeLevelsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof coreDegreeLevelsCreate>>>
    export type CoreDegreeLevelsCreateMutationBody = NonReadonly<DegreeLevel>
    export type CoreDegreeLevelsCreateMutationError = unknown

    export const useCoreDegreeLevelsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsCreate>>, TError,{data: NonReadonly<DegreeLevel>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreDegreeLevelsCreate>>,
        TError,
        {data: NonReadonly<DegreeLevel>},
        TContext
      > => {

      const mutationOptions = getCoreDegreeLevelsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for degree levels.
 */
export const coreDegreeLevelsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<DegreeLevel>(
      {url: `/api/core/degree-levels/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreDegreeLevelsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/degree-levels/${id}/`
    ] as const;
    }

export const getCoreDegreeLevelsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/degree-levels/${id}/`
    ] as const;
    }

    
export const getCoreDegreeLevelsRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreDegreeLevelsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>> = ({ signal }) => coreDegreeLevelsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreDegreeLevelsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>>
export type CoreDegreeLevelsRetrieveInfiniteQueryError = unknown



export function useCoreDegreeLevelsRetrieveInfinite<TData = Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreDegreeLevelsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreDegreeLevelsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreDegreeLevelsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>> = ({ signal }) => coreDegreeLevelsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreDegreeLevelsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>>
export type CoreDegreeLevelsRetrieveQueryError = unknown



export function useCoreDegreeLevelsRetrieve<TData = Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreDegreeLevelsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreDegreeLevelsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for degree levels.
 */
export const coreDegreeLevelsUpdate = (
    id: number,
    degreeLevel: NonReadonly<DegreeLevel>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DegreeLevel>(
      {url: `/api/core/degree-levels/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: degreeLevel
    },
      options);
    }
  


export const getCoreDegreeLevelsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsUpdate>>, TError,{id: number;data: NonReadonly<DegreeLevel>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsUpdate>>, TError,{id: number;data: NonReadonly<DegreeLevel>}, TContext> => {

const mutationKey = ['coreDegreeLevelsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreDegreeLevelsUpdate>>, {id: number;data: NonReadonly<DegreeLevel>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreDegreeLevelsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreDegreeLevelsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreDegreeLevelsUpdate>>>
    export type CoreDegreeLevelsUpdateMutationBody = NonReadonly<DegreeLevel>
    export type CoreDegreeLevelsUpdateMutationError = unknown

    export const useCoreDegreeLevelsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsUpdate>>, TError,{id: number;data: NonReadonly<DegreeLevel>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreDegreeLevelsUpdate>>,
        TError,
        {id: number;data: NonReadonly<DegreeLevel>},
        TContext
      > => {

      const mutationOptions = getCoreDegreeLevelsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for degree levels.
 */
export const coreDegreeLevelsPartialUpdate = (
    id: number,
    patchedDegreeLevel: NonReadonly<PatchedDegreeLevel>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DegreeLevel>(
      {url: `/api/core/degree-levels/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedDegreeLevel
    },
      options);
    }
  


export const getCoreDegreeLevelsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedDegreeLevel>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedDegreeLevel>}, TContext> => {

const mutationKey = ['coreDegreeLevelsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreDegreeLevelsPartialUpdate>>, {id: number;data: NonReadonly<PatchedDegreeLevel>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreDegreeLevelsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreDegreeLevelsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreDegreeLevelsPartialUpdate>>>
    export type CoreDegreeLevelsPartialUpdateMutationBody = NonReadonly<PatchedDegreeLevel>
    export type CoreDegreeLevelsPartialUpdateMutationError = unknown

    export const useCoreDegreeLevelsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedDegreeLevel>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreDegreeLevelsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedDegreeLevel>},
        TContext
      > => {

      const mutationOptions = getCoreDegreeLevelsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for degree levels.
 */
export const coreDegreeLevelsDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/core/degree-levels/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getCoreDegreeLevelsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['coreDegreeLevelsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreDegreeLevelsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  coreDegreeLevelsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreDegreeLevelsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof coreDegreeLevelsDestroy>>>
    
    export type CoreDegreeLevelsDestroyMutationError = unknown

    export const useCoreDegreeLevelsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDegreeLevelsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreDegreeLevelsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCoreDegreeLevelsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for departments.
 */
export const coreDepartmentsList = (
    params?: CoreDepartmentsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedDepartmentList>(
      {url: `/api/core/departments/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreDepartmentsListInfiniteQueryKey = (params?: CoreDepartmentsListParams,) => {
    return [
    'infinate', `/api/core/departments/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreDepartmentsListQueryKey = (params?: CoreDepartmentsListParams,) => {
    return [
    `/api/core/departments/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreDepartmentsListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreDepartmentsList>>, TError = unknown>(params?: CoreDepartmentsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDepartmentsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreDepartmentsListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreDepartmentsList>>> = ({ signal, pageParam }) => coreDepartmentsList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDepartmentsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreDepartmentsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreDepartmentsList>>>
export type CoreDepartmentsListInfiniteQueryError = unknown



export function useCoreDepartmentsListInfinite<TData = Awaited<ReturnType<typeof coreDepartmentsList>>, TError = unknown>(
 params?: CoreDepartmentsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDepartmentsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreDepartmentsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreDepartmentsListQueryOptions = <TData = Awaited<ReturnType<typeof coreDepartmentsList>>, TError = unknown>(params?: CoreDepartmentsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreDepartmentsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreDepartmentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreDepartmentsList>>> = ({ signal }) => coreDepartmentsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreDepartmentsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreDepartmentsListQueryResult = NonNullable<Awaited<ReturnType<typeof coreDepartmentsList>>>
export type CoreDepartmentsListQueryError = unknown



export function useCoreDepartmentsList<TData = Awaited<ReturnType<typeof coreDepartmentsList>>, TError = unknown>(
 params?: CoreDepartmentsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreDepartmentsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreDepartmentsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for departments.
 */
export const coreDepartmentsCreate = (
    department: NonReadonly<Department>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Department>(
      {url: `/api/core/departments/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: department, signal
    },
      options);
    }
  


export const getCoreDepartmentsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsCreate>>, TError,{data: NonReadonly<Department>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsCreate>>, TError,{data: NonReadonly<Department>}, TContext> => {

const mutationKey = ['coreDepartmentsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreDepartmentsCreate>>, {data: NonReadonly<Department>}> = (props) => {
          const {data} = props ?? {};

          return  coreDepartmentsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreDepartmentsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof coreDepartmentsCreate>>>
    export type CoreDepartmentsCreateMutationBody = NonReadonly<Department>
    export type CoreDepartmentsCreateMutationError = unknown

    export const useCoreDepartmentsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsCreate>>, TError,{data: NonReadonly<Department>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreDepartmentsCreate>>,
        TError,
        {data: NonReadonly<Department>},
        TContext
      > => {

      const mutationOptions = getCoreDepartmentsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for departments.
 */
export const coreDepartmentsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Department>(
      {url: `/api/core/departments/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreDepartmentsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/departments/${id}/`
    ] as const;
    }

export const getCoreDepartmentsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/departments/${id}/`
    ] as const;
    }

    
export const getCoreDepartmentsRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreDepartmentsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>> = ({ signal }) => coreDepartmentsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreDepartmentsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>>
export type CoreDepartmentsRetrieveInfiniteQueryError = unknown



export function useCoreDepartmentsRetrieveInfinite<TData = Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreDepartmentsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreDepartmentsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreDepartmentsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>> = ({ signal }) => coreDepartmentsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreDepartmentsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>>
export type CoreDepartmentsRetrieveQueryError = unknown



export function useCoreDepartmentsRetrieve<TData = Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreDepartmentsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreDepartmentsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for departments.
 */
export const coreDepartmentsUpdate = (
    id: number,
    department: NonReadonly<Department>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Department>(
      {url: `/api/core/departments/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: department
    },
      options);
    }
  


export const getCoreDepartmentsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsUpdate>>, TError,{id: number;data: NonReadonly<Department>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsUpdate>>, TError,{id: number;data: NonReadonly<Department>}, TContext> => {

const mutationKey = ['coreDepartmentsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreDepartmentsUpdate>>, {id: number;data: NonReadonly<Department>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreDepartmentsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreDepartmentsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreDepartmentsUpdate>>>
    export type CoreDepartmentsUpdateMutationBody = NonReadonly<Department>
    export type CoreDepartmentsUpdateMutationError = unknown

    export const useCoreDepartmentsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsUpdate>>, TError,{id: number;data: NonReadonly<Department>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreDepartmentsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Department>},
        TContext
      > => {

      const mutationOptions = getCoreDepartmentsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for departments.
 */
export const coreDepartmentsPartialUpdate = (
    id: number,
    patchedDepartment: NonReadonly<PatchedDepartment>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Department>(
      {url: `/api/core/departments/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedDepartment
    },
      options);
    }
  


export const getCoreDepartmentsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedDepartment>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedDepartment>}, TContext> => {

const mutationKey = ['coreDepartmentsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreDepartmentsPartialUpdate>>, {id: number;data: NonReadonly<PatchedDepartment>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreDepartmentsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreDepartmentsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreDepartmentsPartialUpdate>>>
    export type CoreDepartmentsPartialUpdateMutationBody = NonReadonly<PatchedDepartment>
    export type CoreDepartmentsPartialUpdateMutationError = unknown

    export const useCoreDepartmentsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedDepartment>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreDepartmentsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedDepartment>},
        TContext
      > => {

      const mutationOptions = getCoreDepartmentsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for departments.
 */
export const coreDepartmentsDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/core/departments/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getCoreDepartmentsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['coreDepartmentsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreDepartmentsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  coreDepartmentsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreDepartmentsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof coreDepartmentsDestroy>>>
    
    export type CoreDepartmentsDestroyMutationError = unknown

    export const useCoreDepartmentsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreDepartmentsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreDepartmentsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCoreDepartmentsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for learning outcomes.
 */
export const coreLearningOutcomesList = (
    params?: CoreLearningOutcomesListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedCoreLearningOutcomeList>(
      {url: `/api/core/learning-outcomes/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreLearningOutcomesListInfiniteQueryKey = (params?: CoreLearningOutcomesListParams,) => {
    return [
    'infinate', `/api/core/learning-outcomes/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreLearningOutcomesListQueryKey = (params?: CoreLearningOutcomesListParams,) => {
    return [
    `/api/core/learning-outcomes/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreLearningOutcomesListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError = unknown>(params?: CoreLearningOutcomesListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreLearningOutcomesListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreLearningOutcomesList>>> = ({ signal, pageParam }) => coreLearningOutcomesList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreLearningOutcomesListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreLearningOutcomesList>>>
export type CoreLearningOutcomesListInfiniteQueryError = unknown



export function useCoreLearningOutcomesListInfinite<TData = Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError = unknown>(
 params?: CoreLearningOutcomesListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreLearningOutcomesListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreLearningOutcomesListQueryOptions = <TData = Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError = unknown>(params?: CoreLearningOutcomesListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreLearningOutcomesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreLearningOutcomesList>>> = ({ signal }) => coreLearningOutcomesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreLearningOutcomesListQueryResult = NonNullable<Awaited<ReturnType<typeof coreLearningOutcomesList>>>
export type CoreLearningOutcomesListQueryError = unknown



export function useCoreLearningOutcomesList<TData = Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError = unknown>(
 params?: CoreLearningOutcomesListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreLearningOutcomesListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for learning outcomes.
 */
export const coreLearningOutcomesCreate = (
    coreLearningOutcome: NonReadonly<CoreLearningOutcome>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CoreLearningOutcome>(
      {url: `/api/core/learning-outcomes/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: coreLearningOutcome, signal
    },
      options);
    }
  


export const getCoreLearningOutcomesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesCreate>>, TError,{data: NonReadonly<CoreLearningOutcome>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesCreate>>, TError,{data: NonReadonly<CoreLearningOutcome>}, TContext> => {

const mutationKey = ['coreLearningOutcomesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreLearningOutcomesCreate>>, {data: NonReadonly<CoreLearningOutcome>}> = (props) => {
          const {data} = props ?? {};

          return  coreLearningOutcomesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreLearningOutcomesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof coreLearningOutcomesCreate>>>
    export type CoreLearningOutcomesCreateMutationBody = NonReadonly<CoreLearningOutcome>
    export type CoreLearningOutcomesCreateMutationError = unknown

    export const useCoreLearningOutcomesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesCreate>>, TError,{data: NonReadonly<CoreLearningOutcome>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreLearningOutcomesCreate>>,
        TError,
        {data: NonReadonly<CoreLearningOutcome>},
        TContext
      > => {

      const mutationOptions = getCoreLearningOutcomesCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for learning outcomes.
 */
export const coreLearningOutcomesRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CoreLearningOutcome>(
      {url: `/api/core/learning-outcomes/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreLearningOutcomesRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/learning-outcomes/${id}/`
    ] as const;
    }

export const getCoreLearningOutcomesRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/learning-outcomes/${id}/`
    ] as const;
    }

    
export const getCoreLearningOutcomesRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreLearningOutcomesRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>> = ({ signal }) => coreLearningOutcomesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreLearningOutcomesRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>>
export type CoreLearningOutcomesRetrieveInfiniteQueryError = unknown



export function useCoreLearningOutcomesRetrieveInfinite<TData = Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreLearningOutcomesRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreLearningOutcomesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreLearningOutcomesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>> = ({ signal }) => coreLearningOutcomesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreLearningOutcomesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>>
export type CoreLearningOutcomesRetrieveQueryError = unknown



export function useCoreLearningOutcomesRetrieve<TData = Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreLearningOutcomesRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreLearningOutcomesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for learning outcomes.
 */
export const coreLearningOutcomesUpdate = (
    id: number,
    coreLearningOutcome: NonReadonly<CoreLearningOutcome>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CoreLearningOutcome>(
      {url: `/api/core/learning-outcomes/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: coreLearningOutcome
    },
      options);
    }
  


export const getCoreLearningOutcomesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesUpdate>>, TError,{id: number;data: NonReadonly<CoreLearningOutcome>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesUpdate>>, TError,{id: number;data: NonReadonly<CoreLearningOutcome>}, TContext> => {

const mutationKey = ['coreLearningOutcomesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreLearningOutcomesUpdate>>, {id: number;data: NonReadonly<CoreLearningOutcome>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreLearningOutcomesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreLearningOutcomesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreLearningOutcomesUpdate>>>
    export type CoreLearningOutcomesUpdateMutationBody = NonReadonly<CoreLearningOutcome>
    export type CoreLearningOutcomesUpdateMutationError = unknown

    export const useCoreLearningOutcomesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesUpdate>>, TError,{id: number;data: NonReadonly<CoreLearningOutcome>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreLearningOutcomesUpdate>>,
        TError,
        {id: number;data: NonReadonly<CoreLearningOutcome>},
        TContext
      > => {

      const mutationOptions = getCoreLearningOutcomesUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for learning outcomes.
 */
export const coreLearningOutcomesPartialUpdate = (
    id: number,
    patchedCoreLearningOutcome: NonReadonly<PatchedCoreLearningOutcome>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CoreLearningOutcome>(
      {url: `/api/core/learning-outcomes/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCoreLearningOutcome
    },
      options);
    }
  


export const getCoreLearningOutcomesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedCoreLearningOutcome>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedCoreLearningOutcome>}, TContext> => {

const mutationKey = ['coreLearningOutcomesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreLearningOutcomesPartialUpdate>>, {id: number;data: NonReadonly<PatchedCoreLearningOutcome>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreLearningOutcomesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreLearningOutcomesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreLearningOutcomesPartialUpdate>>>
    export type CoreLearningOutcomesPartialUpdateMutationBody = NonReadonly<PatchedCoreLearningOutcome>
    export type CoreLearningOutcomesPartialUpdateMutationError = unknown

    export const useCoreLearningOutcomesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedCoreLearningOutcome>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreLearningOutcomesPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedCoreLearningOutcome>},
        TContext
      > => {

      const mutationOptions = getCoreLearningOutcomesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for learning outcomes.
 */
export const coreLearningOutcomesDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/core/learning-outcomes/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getCoreLearningOutcomesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['coreLearningOutcomesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreLearningOutcomesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  coreLearningOutcomesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreLearningOutcomesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof coreLearningOutcomesDestroy>>>
    
    export type CoreLearningOutcomesDestroyMutationError = unknown

    export const useCoreLearningOutcomesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLearningOutcomesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreLearningOutcomesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCoreLearningOutcomesDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for LO-PO mappings.
 */
export const coreLoPoMappingsList = (
    params?: CoreLoPoMappingsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedLearningOutcomeProgramOutcomeMappingList>(
      {url: `/api/core/lo-po-mappings/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreLoPoMappingsListInfiniteQueryKey = (params?: CoreLoPoMappingsListParams,) => {
    return [
    'infinate', `/api/core/lo-po-mappings/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreLoPoMappingsListQueryKey = (params?: CoreLoPoMappingsListParams,) => {
    return [
    `/api/core/lo-po-mappings/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreLoPoMappingsListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError = unknown>(params?: CoreLoPoMappingsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreLoPoMappingsListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreLoPoMappingsList>>> = ({ signal, pageParam }) => coreLoPoMappingsList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreLoPoMappingsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreLoPoMappingsList>>>
export type CoreLoPoMappingsListInfiniteQueryError = unknown



export function useCoreLoPoMappingsListInfinite<TData = Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError = unknown>(
 params?: CoreLoPoMappingsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreLoPoMappingsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreLoPoMappingsListQueryOptions = <TData = Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError = unknown>(params?: CoreLoPoMappingsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreLoPoMappingsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreLoPoMappingsList>>> = ({ signal }) => coreLoPoMappingsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreLoPoMappingsListQueryResult = NonNullable<Awaited<ReturnType<typeof coreLoPoMappingsList>>>
export type CoreLoPoMappingsListQueryError = unknown



export function useCoreLoPoMappingsList<TData = Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError = unknown>(
 params?: CoreLoPoMappingsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreLoPoMappingsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for LO-PO mappings.
 */
export const coreLoPoMappingsCreate = (
    learningOutcomeProgramOutcomeMapping: NonReadonly<LearningOutcomeProgramOutcomeMapping>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LearningOutcomeProgramOutcomeMapping>(
      {url: `/api/core/lo-po-mappings/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: learningOutcomeProgramOutcomeMapping, signal
    },
      options);
    }
  


export const getCoreLoPoMappingsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsCreate>>, TError,{data: NonReadonly<LearningOutcomeProgramOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsCreate>>, TError,{data: NonReadonly<LearningOutcomeProgramOutcomeMapping>}, TContext> => {

const mutationKey = ['coreLoPoMappingsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreLoPoMappingsCreate>>, {data: NonReadonly<LearningOutcomeProgramOutcomeMapping>}> = (props) => {
          const {data} = props ?? {};

          return  coreLoPoMappingsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreLoPoMappingsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof coreLoPoMappingsCreate>>>
    export type CoreLoPoMappingsCreateMutationBody = NonReadonly<LearningOutcomeProgramOutcomeMapping>
    export type CoreLoPoMappingsCreateMutationError = unknown

    export const useCoreLoPoMappingsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsCreate>>, TError,{data: NonReadonly<LearningOutcomeProgramOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreLoPoMappingsCreate>>,
        TError,
        {data: NonReadonly<LearningOutcomeProgramOutcomeMapping>},
        TContext
      > => {

      const mutationOptions = getCoreLoPoMappingsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for LO-PO mappings.
 */
export const coreLoPoMappingsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LearningOutcomeProgramOutcomeMapping>(
      {url: `/api/core/lo-po-mappings/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreLoPoMappingsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/lo-po-mappings/${id}/`
    ] as const;
    }

export const getCoreLoPoMappingsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/lo-po-mappings/${id}/`
    ] as const;
    }

    
export const getCoreLoPoMappingsRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreLoPoMappingsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>> = ({ signal }) => coreLoPoMappingsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreLoPoMappingsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>>
export type CoreLoPoMappingsRetrieveInfiniteQueryError = unknown



export function useCoreLoPoMappingsRetrieveInfinite<TData = Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreLoPoMappingsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreLoPoMappingsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreLoPoMappingsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>> = ({ signal }) => coreLoPoMappingsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreLoPoMappingsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>>
export type CoreLoPoMappingsRetrieveQueryError = unknown



export function useCoreLoPoMappingsRetrieve<TData = Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreLoPoMappingsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreLoPoMappingsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for LO-PO mappings.
 */
export const coreLoPoMappingsUpdate = (
    id: number,
    learningOutcomeProgramOutcomeMapping: NonReadonly<LearningOutcomeProgramOutcomeMapping>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<LearningOutcomeProgramOutcomeMapping>(
      {url: `/api/core/lo-po-mappings/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: learningOutcomeProgramOutcomeMapping
    },
      options);
    }
  


export const getCoreLoPoMappingsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsUpdate>>, TError,{id: number;data: NonReadonly<LearningOutcomeProgramOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsUpdate>>, TError,{id: number;data: NonReadonly<LearningOutcomeProgramOutcomeMapping>}, TContext> => {

const mutationKey = ['coreLoPoMappingsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreLoPoMappingsUpdate>>, {id: number;data: NonReadonly<LearningOutcomeProgramOutcomeMapping>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreLoPoMappingsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreLoPoMappingsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreLoPoMappingsUpdate>>>
    export type CoreLoPoMappingsUpdateMutationBody = NonReadonly<LearningOutcomeProgramOutcomeMapping>
    export type CoreLoPoMappingsUpdateMutationError = unknown

    export const useCoreLoPoMappingsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsUpdate>>, TError,{id: number;data: NonReadonly<LearningOutcomeProgramOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreLoPoMappingsUpdate>>,
        TError,
        {id: number;data: NonReadonly<LearningOutcomeProgramOutcomeMapping>},
        TContext
      > => {

      const mutationOptions = getCoreLoPoMappingsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for LO-PO mappings.
 */
export const coreLoPoMappingsPartialUpdate = (
    id: number,
    patchedLearningOutcomeProgramOutcomeMapping: NonReadonly<PatchedLearningOutcomeProgramOutcomeMapping>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<LearningOutcomeProgramOutcomeMapping>(
      {url: `/api/core/lo-po-mappings/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedLearningOutcomeProgramOutcomeMapping
    },
      options);
    }
  


export const getCoreLoPoMappingsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedLearningOutcomeProgramOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedLearningOutcomeProgramOutcomeMapping>}, TContext> => {

const mutationKey = ['coreLoPoMappingsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreLoPoMappingsPartialUpdate>>, {id: number;data: NonReadonly<PatchedLearningOutcomeProgramOutcomeMapping>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreLoPoMappingsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreLoPoMappingsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreLoPoMappingsPartialUpdate>>>
    export type CoreLoPoMappingsPartialUpdateMutationBody = NonReadonly<PatchedLearningOutcomeProgramOutcomeMapping>
    export type CoreLoPoMappingsPartialUpdateMutationError = unknown

    export const useCoreLoPoMappingsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedLearningOutcomeProgramOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreLoPoMappingsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedLearningOutcomeProgramOutcomeMapping>},
        TContext
      > => {

      const mutationOptions = getCoreLoPoMappingsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for LO-PO mappings.
 */
export const coreLoPoMappingsDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/core/lo-po-mappings/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getCoreLoPoMappingsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['coreLoPoMappingsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreLoPoMappingsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  coreLoPoMappingsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreLoPoMappingsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof coreLoPoMappingsDestroy>>>
    
    export type CoreLoPoMappingsDestroyMutationError = unknown

    export const useCoreLoPoMappingsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreLoPoMappingsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreLoPoMappingsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCoreLoPoMappingsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for programs.
 */
export const coreProgramsList = (
    params?: CoreProgramsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedProgramList>(
      {url: `/api/core/programs/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreProgramsListInfiniteQueryKey = (params?: CoreProgramsListParams,) => {
    return [
    'infinate', `/api/core/programs/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreProgramsListQueryKey = (params?: CoreProgramsListParams,) => {
    return [
    `/api/core/programs/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreProgramsListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreProgramsList>>, TError = unknown>(params?: CoreProgramsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreProgramsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreProgramsListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreProgramsList>>> = ({ signal, pageParam }) => coreProgramsList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreProgramsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreProgramsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreProgramsList>>>
export type CoreProgramsListInfiniteQueryError = unknown



export function useCoreProgramsListInfinite<TData = Awaited<ReturnType<typeof coreProgramsList>>, TError = unknown>(
 params?: CoreProgramsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreProgramsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreProgramsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreProgramsListQueryOptions = <TData = Awaited<ReturnType<typeof coreProgramsList>>, TError = unknown>(params?: CoreProgramsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreProgramsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreProgramsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreProgramsList>>> = ({ signal }) => coreProgramsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreProgramsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreProgramsListQueryResult = NonNullable<Awaited<ReturnType<typeof coreProgramsList>>>
export type CoreProgramsListQueryError = unknown



export function useCoreProgramsList<TData = Awaited<ReturnType<typeof coreProgramsList>>, TError = unknown>(
 params?: CoreProgramsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreProgramsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreProgramsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for programs.
 */
export const coreProgramsCreate = (
    program: NonReadonly<Program>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Program>(
      {url: `/api/core/programs/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: program, signal
    },
      options);
    }
  


export const getCoreProgramsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreProgramsCreate>>, TError,{data: NonReadonly<Program>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreProgramsCreate>>, TError,{data: NonReadonly<Program>}, TContext> => {

const mutationKey = ['coreProgramsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreProgramsCreate>>, {data: NonReadonly<Program>}> = (props) => {
          const {data} = props ?? {};

          return  coreProgramsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreProgramsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof coreProgramsCreate>>>
    export type CoreProgramsCreateMutationBody = NonReadonly<Program>
    export type CoreProgramsCreateMutationError = unknown

    export const useCoreProgramsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreProgramsCreate>>, TError,{data: NonReadonly<Program>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreProgramsCreate>>,
        TError,
        {data: NonReadonly<Program>},
        TContext
      > => {

      const mutationOptions = getCoreProgramsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for programs.
 */
export const coreProgramsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Program>(
      {url: `/api/core/programs/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreProgramsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/programs/${id}/`
    ] as const;
    }

export const getCoreProgramsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/programs/${id}/`
    ] as const;
    }

    
export const getCoreProgramsRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreProgramsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreProgramsRetrieve>>> = ({ signal }) => coreProgramsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreProgramsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreProgramsRetrieve>>>
export type CoreProgramsRetrieveInfiniteQueryError = unknown



export function useCoreProgramsRetrieveInfinite<TData = Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreProgramsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreProgramsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreProgramsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreProgramsRetrieve>>> = ({ signal }) => coreProgramsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreProgramsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreProgramsRetrieve>>>
export type CoreProgramsRetrieveQueryError = unknown



export function useCoreProgramsRetrieve<TData = Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreProgramsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreProgramsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for programs.
 */
export const coreProgramsUpdate = (
    id: number,
    program: NonReadonly<Program>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Program>(
      {url: `/api/core/programs/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: program
    },
      options);
    }
  


export const getCoreProgramsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreProgramsUpdate>>, TError,{id: number;data: NonReadonly<Program>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreProgramsUpdate>>, TError,{id: number;data: NonReadonly<Program>}, TContext> => {

const mutationKey = ['coreProgramsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreProgramsUpdate>>, {id: number;data: NonReadonly<Program>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreProgramsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreProgramsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreProgramsUpdate>>>
    export type CoreProgramsUpdateMutationBody = NonReadonly<Program>
    export type CoreProgramsUpdateMutationError = unknown

    export const useCoreProgramsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreProgramsUpdate>>, TError,{id: number;data: NonReadonly<Program>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreProgramsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Program>},
        TContext
      > => {

      const mutationOptions = getCoreProgramsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for programs.
 */
export const coreProgramsPartialUpdate = (
    id: number,
    patchedProgram: NonReadonly<PatchedProgram>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Program>(
      {url: `/api/core/programs/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedProgram
    },
      options);
    }
  


export const getCoreProgramsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreProgramsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedProgram>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreProgramsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedProgram>}, TContext> => {

const mutationKey = ['coreProgramsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreProgramsPartialUpdate>>, {id: number;data: NonReadonly<PatchedProgram>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreProgramsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreProgramsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreProgramsPartialUpdate>>>
    export type CoreProgramsPartialUpdateMutationBody = NonReadonly<PatchedProgram>
    export type CoreProgramsPartialUpdateMutationError = unknown

    export const useCoreProgramsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreProgramsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedProgram>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreProgramsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedProgram>},
        TContext
      > => {

      const mutationOptions = getCoreProgramsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for programs.
 */
export const coreProgramsDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/core/programs/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getCoreProgramsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreProgramsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreProgramsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['coreProgramsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreProgramsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  coreProgramsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreProgramsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof coreProgramsDestroy>>>
    
    export type CoreProgramsDestroyMutationError = unknown

    export const useCoreProgramsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreProgramsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreProgramsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCoreProgramsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Read-only access to calculated LO scores.
 */
export const coreStudentLoScoresList = (
    params?: CoreStudentLoScoresListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedStudentLearningOutcomeScoreList>(
      {url: `/api/core/student-lo-scores/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreStudentLoScoresListInfiniteQueryKey = (params?: CoreStudentLoScoresListParams,) => {
    return [
    'infinate', `/api/core/student-lo-scores/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreStudentLoScoresListQueryKey = (params?: CoreStudentLoScoresListParams,) => {
    return [
    `/api/core/student-lo-scores/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreStudentLoScoresListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError = unknown>(params?: CoreStudentLoScoresListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentLoScoresListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentLoScoresList>>> = ({ signal, pageParam }) => coreStudentLoScoresList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentLoScoresListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentLoScoresList>>>
export type CoreStudentLoScoresListInfiniteQueryError = unknown



export function useCoreStudentLoScoresListInfinite<TData = Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError = unknown>(
 params?: CoreStudentLoScoresListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentLoScoresListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreStudentLoScoresListQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError = unknown>(params?: CoreStudentLoScoresListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentLoScoresListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentLoScoresList>>> = ({ signal }) => coreStudentLoScoresList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentLoScoresListQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentLoScoresList>>>
export type CoreStudentLoScoresListQueryError = unknown



export function useCoreStudentLoScoresList<TData = Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError = unknown>(
 params?: CoreStudentLoScoresListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentLoScoresListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Read-only access to calculated LO scores.
 */
export const coreStudentLoScoresRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StudentLearningOutcomeScore>(
      {url: `/api/core/student-lo-scores/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreStudentLoScoresRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/student-lo-scores/${id}/`
    ] as const;
    }

export const getCoreStudentLoScoresRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/student-lo-scores/${id}/`
    ] as const;
    }

    
export const getCoreStudentLoScoresRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentLoScoresRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>> = ({ signal }) => coreStudentLoScoresRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentLoScoresRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>>
export type CoreStudentLoScoresRetrieveInfiniteQueryError = unknown



export function useCoreStudentLoScoresRetrieveInfinite<TData = Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentLoScoresRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreStudentLoScoresRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentLoScoresRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>> = ({ signal }) => coreStudentLoScoresRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentLoScoresRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>>
export type CoreStudentLoScoresRetrieveQueryError = unknown



export function useCoreStudentLoScoresRetrieve<TData = Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentLoScoresRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentLoScoresRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Read-only access to calculated PO scores.
 */
export const coreStudentPoScoresList = (
    params?: CoreStudentPoScoresListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedStudentProgramOutcomeScoreList>(
      {url: `/api/core/student-po-scores/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreStudentPoScoresListInfiniteQueryKey = (params?: CoreStudentPoScoresListParams,) => {
    return [
    'infinate', `/api/core/student-po-scores/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreStudentPoScoresListQueryKey = (params?: CoreStudentPoScoresListParams,) => {
    return [
    `/api/core/student-po-scores/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreStudentPoScoresListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError = unknown>(params?: CoreStudentPoScoresListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentPoScoresListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentPoScoresList>>> = ({ signal, pageParam }) => coreStudentPoScoresList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentPoScoresListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentPoScoresList>>>
export type CoreStudentPoScoresListInfiniteQueryError = unknown



export function useCoreStudentPoScoresListInfinite<TData = Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError = unknown>(
 params?: CoreStudentPoScoresListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentPoScoresListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreStudentPoScoresListQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError = unknown>(params?: CoreStudentPoScoresListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentPoScoresListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentPoScoresList>>> = ({ signal }) => coreStudentPoScoresList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentPoScoresListQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentPoScoresList>>>
export type CoreStudentPoScoresListQueryError = unknown



export function useCoreStudentPoScoresList<TData = Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError = unknown>(
 params?: CoreStudentPoScoresListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentPoScoresListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Read-only access to calculated PO scores.
 */
export const coreStudentPoScoresRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StudentProgramOutcomeScore>(
      {url: `/api/core/student-po-scores/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreStudentPoScoresRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/student-po-scores/${id}/`
    ] as const;
    }

export const getCoreStudentPoScoresRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/student-po-scores/${id}/`
    ] as const;
    }

    
export const getCoreStudentPoScoresRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentPoScoresRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>> = ({ signal }) => coreStudentPoScoresRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentPoScoresRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>>
export type CoreStudentPoScoresRetrieveInfiniteQueryError = unknown



export function useCoreStudentPoScoresRetrieveInfinite<TData = Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentPoScoresRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreStudentPoScoresRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentPoScoresRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>> = ({ signal }) => coreStudentPoScoresRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentPoScoresRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>>
export type CoreStudentPoScoresRetrieveQueryError = unknown



export function useCoreStudentPoScoresRetrieve<TData = Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentPoScoresRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentPoScoresRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const coreStudentsList = (
    params?: CoreStudentsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedStudentProfileList>(
      {url: `/api/core/students/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreStudentsListInfiniteQueryKey = (params?: CoreStudentsListParams,) => {
    return [
    'infinate', `/api/core/students/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreStudentsListQueryKey = (params?: CoreStudentsListParams,) => {
    return [
    `/api/core/students/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreStudentsListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentsList>>, TError = unknown>(params?: CoreStudentsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentsListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentsList>>> = ({ signal, pageParam }) => coreStudentsList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentsList>>>
export type CoreStudentsListInfiniteQueryError = unknown



export function useCoreStudentsListInfinite<TData = Awaited<ReturnType<typeof coreStudentsList>>, TError = unknown>(
 params?: CoreStudentsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreStudentsListQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentsList>>, TError = unknown>(params?: CoreStudentsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentsList>>> = ({ signal }) => coreStudentsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreStudentsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentsListQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentsList>>>
export type CoreStudentsListQueryError = unknown



export function useCoreStudentsList<TData = Awaited<ReturnType<typeof coreStudentsList>>, TError = unknown>(
 params?: CoreStudentsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const coreStudentsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StudentProfile>(
      {url: `/api/core/students/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreStudentsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/students/${id}/`
    ] as const;
    }

export const getCoreStudentsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/students/${id}/`
    ] as const;
    }

    
export const getCoreStudentsRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentsRetrieve>>> = ({ signal }) => coreStudentsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentsRetrieve>>>
export type CoreStudentsRetrieveInfiniteQueryError = unknown



export function useCoreStudentsRetrieveInfinite<TData = Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreStudentsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreStudentsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreStudentsRetrieve>>> = ({ signal }) => coreStudentsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreStudentsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreStudentsRetrieve>>>
export type CoreStudentsRetrieveQueryError = unknown



export function useCoreStudentsRetrieve<TData = Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreStudentsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreStudentsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for terms.
 */
export const coreTermsList = (
    params?: CoreTermsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedTermList>(
      {url: `/api/core/terms/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getCoreTermsListInfiniteQueryKey = (params?: CoreTermsListParams,) => {
    return [
    'infinate', `/api/core/terms/`, ...(params ? [params]: [])
    ] as const;
    }

export const getCoreTermsListQueryKey = (params?: CoreTermsListParams,) => {
    return [
    `/api/core/terms/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreTermsListInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreTermsList>>, TError = unknown>(params?: CoreTermsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreTermsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreTermsListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreTermsList>>> = ({ signal, pageParam }) => coreTermsList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreTermsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreTermsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreTermsList>>>
export type CoreTermsListInfiniteQueryError = unknown



export function useCoreTermsListInfinite<TData = Awaited<ReturnType<typeof coreTermsList>>, TError = unknown>(
 params?: CoreTermsListParams, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreTermsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreTermsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreTermsListQueryOptions = <TData = Awaited<ReturnType<typeof coreTermsList>>, TError = unknown>(params?: CoreTermsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreTermsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreTermsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreTermsList>>> = ({ signal }) => coreTermsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreTermsList>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreTermsListQueryResult = NonNullable<Awaited<ReturnType<typeof coreTermsList>>>
export type CoreTermsListQueryError = unknown



export function useCoreTermsList<TData = Awaited<ReturnType<typeof coreTermsList>>, TError = unknown>(
 params?: CoreTermsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreTermsList>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreTermsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for terms.
 */
export const coreTermsCreate = (
    term: NonReadonly<Term>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Term>(
      {url: `/api/core/terms/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: term, signal
    },
      options);
    }
  


export const getCoreTermsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreTermsCreate>>, TError,{data: NonReadonly<Term>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreTermsCreate>>, TError,{data: NonReadonly<Term>}, TContext> => {

const mutationKey = ['coreTermsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreTermsCreate>>, {data: NonReadonly<Term>}> = (props) => {
          const {data} = props ?? {};

          return  coreTermsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreTermsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof coreTermsCreate>>>
    export type CoreTermsCreateMutationBody = NonReadonly<Term>
    export type CoreTermsCreateMutationError = unknown

    export const useCoreTermsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreTermsCreate>>, TError,{data: NonReadonly<Term>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreTermsCreate>>,
        TError,
        {data: NonReadonly<Term>},
        TContext
      > => {

      const mutationOptions = getCoreTermsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for terms.
 */
export const coreTermsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Term>(
      {url: `/api/core/terms/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreTermsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/core/terms/${id}/`
    ] as const;
    }

export const getCoreTermsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/core/terms/${id}/`
    ] as const;
    }

    
export const getCoreTermsRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreTermsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreTermsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreTermsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreTermsRetrieve>>> = ({ signal }) => coreTermsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreTermsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreTermsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreTermsRetrieve>>>
export type CoreTermsRetrieveInfiniteQueryError = unknown



export function useCoreTermsRetrieveInfinite<TData = Awaited<ReturnType<typeof coreTermsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreTermsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreTermsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreTermsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreTermsRetrieve>>, TError = unknown>(id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreTermsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreTermsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreTermsRetrieve>>> = ({ signal }) => coreTermsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreTermsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreTermsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreTermsRetrieve>>>
export type CoreTermsRetrieveQueryError = unknown



export function useCoreTermsRetrieve<TData = Awaited<ReturnType<typeof coreTermsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreTermsRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreTermsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for terms.
 */
export const coreTermsUpdate = (
    id: number,
    term: NonReadonly<Term>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Term>(
      {url: `/api/core/terms/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: term
    },
      options);
    }
  


export const getCoreTermsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreTermsUpdate>>, TError,{id: number;data: NonReadonly<Term>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreTermsUpdate>>, TError,{id: number;data: NonReadonly<Term>}, TContext> => {

const mutationKey = ['coreTermsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreTermsUpdate>>, {id: number;data: NonReadonly<Term>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreTermsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreTermsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreTermsUpdate>>>
    export type CoreTermsUpdateMutationBody = NonReadonly<Term>
    export type CoreTermsUpdateMutationError = unknown

    export const useCoreTermsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreTermsUpdate>>, TError,{id: number;data: NonReadonly<Term>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreTermsUpdate>>,
        TError,
        {id: number;data: NonReadonly<Term>},
        TContext
      > => {

      const mutationOptions = getCoreTermsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for terms.
 */
export const coreTermsPartialUpdate = (
    id: number,
    patchedTerm: NonReadonly<PatchedTerm>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Term>(
      {url: `/api/core/terms/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedTerm
    },
      options);
    }
  


export const getCoreTermsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreTermsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedTerm>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreTermsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedTerm>}, TContext> => {

const mutationKey = ['coreTermsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreTermsPartialUpdate>>, {id: number;data: NonReadonly<PatchedTerm>}> = (props) => {
          const {id,data} = props ?? {};

          return  coreTermsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreTermsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coreTermsPartialUpdate>>>
    export type CoreTermsPartialUpdateMutationBody = NonReadonly<PatchedTerm>
    export type CoreTermsPartialUpdateMutationError = unknown

    export const useCoreTermsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreTermsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedTerm>}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreTermsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedTerm>},
        TContext
      > => {

      const mutationOptions = getCoreTermsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * CRUD operations for terms.
 */
export const coreTermsDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/core/terms/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getCoreTermsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreTermsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coreTermsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['coreTermsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreTermsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  coreTermsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreTermsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof coreTermsDestroy>>>
    
    export type CoreTermsDestroyMutationError = unknown

    export const useCoreTermsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreTermsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof coreTermsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCoreTermsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Get currently active term.
 */
export const coreTermsActiveRetrieve = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Term>(
      {url: `/api/core/terms/active/`, method: 'GET', signal
    },
      options);
    }
  



export const getCoreTermsActiveRetrieveInfiniteQueryKey = () => {
    return [
    'infinate', `/api/core/terms/active/`
    ] as const;
    }

export const getCoreTermsActiveRetrieveQueryKey = () => {
    return [
    `/api/core/terms/active/`
    ] as const;
    }

    
export const getCoreTermsActiveRetrieveInfiniteQueryOptions = <TData = Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError = unknown>( options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreTermsActiveRetrieveInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>> = ({ signal }) => coreTermsActiveRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreTermsActiveRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>>
export type CoreTermsActiveRetrieveInfiniteQueryError = unknown



export function useCoreTermsActiveRetrieveInfinite<TData = Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError = unknown>(
  options?: { query?:UseInfiniteQueryOptions<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreTermsActiveRetrieveInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getCoreTermsActiveRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreTermsActiveRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>> = ({ signal }) => coreTermsActiveRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type CoreTermsActiveRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>>
export type CoreTermsActiveRetrieveQueryError = unknown



export function useCoreTermsActiveRetrieve<TData = Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof coreTermsActiveRetrieve>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCoreTermsActiveRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



