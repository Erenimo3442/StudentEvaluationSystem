/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Student Evaluation System API
 * Outcome-based assessment system for academic programs
 * OpenAPI spec version: 1.0.0
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Assessment,
  AssessmentCreate,
  AssessmentLearningOutcomeMapping,
  CourseEnrollment,
  EvaluationAssessmentLoMappingsListParams,
  EvaluationAssessmentsListParams,
  EvaluationEnrollmentsListParams,
  EvaluationEvaluationListParams,
  EvaluationGradesListParams,
  PaginatedAssessmentLearningOutcomeMappingList,
  PaginatedAssessmentList,
  PaginatedCourseEnrollmentList,
  PaginatedStudentGradeList,
  PatchedAssessmentCreate,
  PatchedAssessmentLearningOutcomeMapping,
  PatchedCourseEnrollment,
  PatchedStudentGradeCreate,
  StudentGrade,
  StudentGradeCreate
} from '../../model';

import { customInstance } from '../../mutator';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * CRUD operations for assessment-LO mappings.
 */
export const evaluationAssessmentLoMappingsList = (
    params?: EvaluationAssessmentLoMappingsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedAssessmentLearningOutcomeMappingList>(
      {url: `/api/evaluation/assessment-lo-mappings/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getEvaluationAssessmentLoMappingsListInfiniteQueryKey = (params?: EvaluationAssessmentLoMappingsListParams,) => {
    return [
    'infinate', `/api/evaluation/assessment-lo-mappings/`, ...(params ? [params]: [])
    ] as const;
    }

export const getEvaluationAssessmentLoMappingsListQueryKey = (params?: EvaluationAssessmentLoMappingsListParams,) => {
    return [
    `/api/evaluation/assessment-lo-mappings/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getEvaluationAssessmentLoMappingsListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, EvaluationAssessmentLoMappingsListParams['page']>, TError = unknown>(params?: EvaluationAssessmentLoMappingsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData, QueryKey, EvaluationAssessmentLoMappingsListParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentLoMappingsListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, QueryKey, EvaluationAssessmentLoMappingsListParams['page']> = ({ signal, pageParam }) => evaluationAssessmentLoMappingsList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData, QueryKey, EvaluationAssessmentLoMappingsListParams['page']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentLoMappingsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>>
export type EvaluationAssessmentLoMappingsListInfiniteQueryError = unknown


export function useEvaluationAssessmentLoMappingsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, EvaluationAssessmentLoMappingsListParams['page']>, TError = unknown>(
 params: undefined |  EvaluationAssessmentLoMappingsListParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData, QueryKey, EvaluationAssessmentLoMappingsListParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentLoMappingsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, EvaluationAssessmentLoMappingsListParams['page']>, TError = unknown>(
 params?: EvaluationAssessmentLoMappingsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData, QueryKey, EvaluationAssessmentLoMappingsListParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentLoMappingsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, EvaluationAssessmentLoMappingsListParams['page']>, TError = unknown>(
 params?: EvaluationAssessmentLoMappingsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData, QueryKey, EvaluationAssessmentLoMappingsListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentLoMappingsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, EvaluationAssessmentLoMappingsListParams['page']>, TError = unknown>(
 params?: EvaluationAssessmentLoMappingsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData, QueryKey, EvaluationAssessmentLoMappingsListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentLoMappingsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationAssessmentLoMappingsListQueryOptions = <TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError = unknown>(params?: EvaluationAssessmentLoMappingsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentLoMappingsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>> = ({ signal }) => evaluationAssessmentLoMappingsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentLoMappingsListQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>>
export type EvaluationAssessmentLoMappingsListQueryError = unknown


export function useEvaluationAssessmentLoMappingsList<TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError = unknown>(
 params: undefined |  EvaluationAssessmentLoMappingsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentLoMappingsList<TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError = unknown>(
 params?: EvaluationAssessmentLoMappingsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentLoMappingsList<TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError = unknown>(
 params?: EvaluationAssessmentLoMappingsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentLoMappingsList<TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError = unknown>(
 params?: EvaluationAssessmentLoMappingsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentLoMappingsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for assessment-LO mappings.
 */
export const evaluationAssessmentLoMappingsCreate = (
    assessmentLearningOutcomeMapping: NonReadonly<AssessmentLearningOutcomeMapping>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AssessmentLearningOutcomeMapping>(
      {url: `/api/evaluation/assessment-lo-mappings/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assessmentLearningOutcomeMapping, signal
    },
      options);
    }
  


export const getEvaluationAssessmentLoMappingsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsCreate>>, TError,{data: NonReadonly<AssessmentLearningOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsCreate>>, TError,{data: NonReadonly<AssessmentLearningOutcomeMapping>}, TContext> => {

const mutationKey = ['evaluationAssessmentLoMappingsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsCreate>>, {data: NonReadonly<AssessmentLearningOutcomeMapping>}> = (props) => {
          const {data} = props ?? {};

          return  evaluationAssessmentLoMappingsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationAssessmentLoMappingsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsCreate>>>
    export type EvaluationAssessmentLoMappingsCreateMutationBody = NonReadonly<AssessmentLearningOutcomeMapping>
    export type EvaluationAssessmentLoMappingsCreateMutationError = unknown

    export const useEvaluationAssessmentLoMappingsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsCreate>>, TError,{data: NonReadonly<AssessmentLearningOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationAssessmentLoMappingsCreate>>,
        TError,
        {data: NonReadonly<AssessmentLearningOutcomeMapping>},
        TContext
      > => {

      const mutationOptions = getEvaluationAssessmentLoMappingsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for assessment-LO mappings.
 */
export const evaluationAssessmentLoMappingsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AssessmentLearningOutcomeMapping>(
      {url: `/api/evaluation/assessment-lo-mappings/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getEvaluationAssessmentLoMappingsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/evaluation/assessment-lo-mappings/${id}/`
    ] as const;
    }

export const getEvaluationAssessmentLoMappingsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/evaluation/assessment-lo-mappings/${id}/`
    ] as const;
    }

    
export const getEvaluationAssessmentLoMappingsRetrieveInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentLoMappingsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>> = ({ signal }) => evaluationAssessmentLoMappingsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentLoMappingsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>>
export type EvaluationAssessmentLoMappingsRetrieveInfiniteQueryError = unknown


export function useEvaluationAssessmentLoMappingsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentLoMappingsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentLoMappingsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentLoMappingsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentLoMappingsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationAssessmentLoMappingsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentLoMappingsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>> = ({ signal }) => evaluationAssessmentLoMappingsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentLoMappingsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>>
export type EvaluationAssessmentLoMappingsRetrieveQueryError = unknown


export function useEvaluationAssessmentLoMappingsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentLoMappingsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentLoMappingsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentLoMappingsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentLoMappingsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for assessment-LO mappings.
 */
export const evaluationAssessmentLoMappingsUpdate = (
    id: number,
    assessmentLearningOutcomeMapping: NonReadonly<AssessmentLearningOutcomeMapping>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<AssessmentLearningOutcomeMapping>(
      {url: `/api/evaluation/assessment-lo-mappings/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assessmentLearningOutcomeMapping
    },
      options);
    }
  


export const getEvaluationAssessmentLoMappingsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsUpdate>>, TError,{id: number;data: NonReadonly<AssessmentLearningOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsUpdate>>, TError,{id: number;data: NonReadonly<AssessmentLearningOutcomeMapping>}, TContext> => {

const mutationKey = ['evaluationAssessmentLoMappingsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsUpdate>>, {id: number;data: NonReadonly<AssessmentLearningOutcomeMapping>}> = (props) => {
          const {id,data} = props ?? {};

          return  evaluationAssessmentLoMappingsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationAssessmentLoMappingsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsUpdate>>>
    export type EvaluationAssessmentLoMappingsUpdateMutationBody = NonReadonly<AssessmentLearningOutcomeMapping>
    export type EvaluationAssessmentLoMappingsUpdateMutationError = unknown

    export const useEvaluationAssessmentLoMappingsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsUpdate>>, TError,{id: number;data: NonReadonly<AssessmentLearningOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationAssessmentLoMappingsUpdate>>,
        TError,
        {id: number;data: NonReadonly<AssessmentLearningOutcomeMapping>},
        TContext
      > => {

      const mutationOptions = getEvaluationAssessmentLoMappingsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for assessment-LO mappings.
 */
export const evaluationAssessmentLoMappingsPartialUpdate = (
    id: number,
    patchedAssessmentLearningOutcomeMapping: NonReadonly<PatchedAssessmentLearningOutcomeMapping>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<AssessmentLearningOutcomeMapping>(
      {url: `/api/evaluation/assessment-lo-mappings/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedAssessmentLearningOutcomeMapping
    },
      options);
    }
  


export const getEvaluationAssessmentLoMappingsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAssessmentLearningOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAssessmentLearningOutcomeMapping>}, TContext> => {

const mutationKey = ['evaluationAssessmentLoMappingsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsPartialUpdate>>, {id: number;data: NonReadonly<PatchedAssessmentLearningOutcomeMapping>}> = (props) => {
          const {id,data} = props ?? {};

          return  evaluationAssessmentLoMappingsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationAssessmentLoMappingsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsPartialUpdate>>>
    export type EvaluationAssessmentLoMappingsPartialUpdateMutationBody = NonReadonly<PatchedAssessmentLearningOutcomeMapping>
    export type EvaluationAssessmentLoMappingsPartialUpdateMutationError = unknown

    export const useEvaluationAssessmentLoMappingsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAssessmentLearningOutcomeMapping>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationAssessmentLoMappingsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedAssessmentLearningOutcomeMapping>},
        TContext
      > => {

      const mutationOptions = getEvaluationAssessmentLoMappingsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for assessment-LO mappings.
 */
export const evaluationAssessmentLoMappingsDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/evaluation/assessment-lo-mappings/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getEvaluationAssessmentLoMappingsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['evaluationAssessmentLoMappingsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  evaluationAssessmentLoMappingsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationAssessmentLoMappingsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsDestroy>>>
    
    export type EvaluationAssessmentLoMappingsDestroyMutationError = unknown

    export const useEvaluationAssessmentLoMappingsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentLoMappingsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationAssessmentLoMappingsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getEvaluationAssessmentLoMappingsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for assessments.
 */
export const evaluationAssessmentsList = (
    params?: EvaluationAssessmentsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedAssessmentList>(
      {url: `/api/evaluation/assessments/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getEvaluationAssessmentsListInfiniteQueryKey = (params?: EvaluationAssessmentsListParams,) => {
    return [
    'infinate', `/api/evaluation/assessments/`, ...(params ? [params]: [])
    ] as const;
    }

export const getEvaluationAssessmentsListQueryKey = (params?: EvaluationAssessmentsListParams,) => {
    return [
    `/api/evaluation/assessments/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getEvaluationAssessmentsListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsList>>, EvaluationAssessmentsListParams['page']>, TError = unknown>(params?: EvaluationAssessmentsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData, QueryKey, EvaluationAssessmentsListParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentsListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentsList>>, QueryKey, EvaluationAssessmentsListParams['page']> = ({ signal, pageParam }) => evaluationAssessmentsList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData, QueryKey, EvaluationAssessmentsListParams['page']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsList>>>
export type EvaluationAssessmentsListInfiniteQueryError = unknown


export function useEvaluationAssessmentsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsList>>, EvaluationAssessmentsListParams['page']>, TError = unknown>(
 params: undefined |  EvaluationAssessmentsListParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData, QueryKey, EvaluationAssessmentsListParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsList>>, EvaluationAssessmentsListParams['page']>, TError = unknown>(
 params?: EvaluationAssessmentsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData, QueryKey, EvaluationAssessmentsListParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsList>>, EvaluationAssessmentsListParams['page']>, TError = unknown>(
 params?: EvaluationAssessmentsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData, QueryKey, EvaluationAssessmentsListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsList>>, EvaluationAssessmentsListParams['page']>, TError = unknown>(
 params?: EvaluationAssessmentsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData, QueryKey, EvaluationAssessmentsListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationAssessmentsListQueryOptions = <TData = Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError = unknown>(params?: EvaluationAssessmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentsList>>> = ({ signal }) => evaluationAssessmentsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentsListQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsList>>>
export type EvaluationAssessmentsListQueryError = unknown


export function useEvaluationAssessmentsList<TData = Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError = unknown>(
 params: undefined |  EvaluationAssessmentsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsList<TData = Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError = unknown>(
 params?: EvaluationAssessmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsList<TData = Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError = unknown>(
 params?: EvaluationAssessmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentsList<TData = Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError = unknown>(
 params?: EvaluationAssessmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for assessments.
 */
export const evaluationAssessmentsCreate = (
    assessmentCreate: NonReadonly<AssessmentCreate>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AssessmentCreate>(
      {url: `/api/evaluation/assessments/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assessmentCreate, signal
    },
      options);
    }
  


export const getEvaluationAssessmentsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsCreate>>, TError,{data: NonReadonly<AssessmentCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsCreate>>, TError,{data: NonReadonly<AssessmentCreate>}, TContext> => {

const mutationKey = ['evaluationAssessmentsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationAssessmentsCreate>>, {data: NonReadonly<AssessmentCreate>}> = (props) => {
          const {data} = props ?? {};

          return  evaluationAssessmentsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationAssessmentsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsCreate>>>
    export type EvaluationAssessmentsCreateMutationBody = NonReadonly<AssessmentCreate>
    export type EvaluationAssessmentsCreateMutationError = unknown

    export const useEvaluationAssessmentsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsCreate>>, TError,{data: NonReadonly<AssessmentCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationAssessmentsCreate>>,
        TError,
        {data: NonReadonly<AssessmentCreate>},
        TContext
      > => {

      const mutationOptions = getEvaluationAssessmentsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for assessments.
 */
export const evaluationAssessmentsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Assessment>(
      {url: `/api/evaluation/assessments/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getEvaluationAssessmentsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/evaluation/assessments/${id}/`
    ] as const;
    }

export const getEvaluationAssessmentsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/evaluation/assessments/${id}/`
    ] as const;
    }

    
export const getEvaluationAssessmentsRetrieveInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>> = ({ signal }) => evaluationAssessmentsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>>
export type EvaluationAssessmentsRetrieveInfiniteQueryError = unknown


export function useEvaluationAssessmentsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationAssessmentsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>> = ({ signal }) => evaluationAssessmentsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>>
export type EvaluationAssessmentsRetrieveQueryError = unknown


export function useEvaluationAssessmentsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for assessments.
 */
export const evaluationAssessmentsUpdate = (
    id: number,
    assessmentCreate: NonReadonly<AssessmentCreate>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<AssessmentCreate>(
      {url: `/api/evaluation/assessments/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assessmentCreate
    },
      options);
    }
  


export const getEvaluationAssessmentsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsUpdate>>, TError,{id: number;data: NonReadonly<AssessmentCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsUpdate>>, TError,{id: number;data: NonReadonly<AssessmentCreate>}, TContext> => {

const mutationKey = ['evaluationAssessmentsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationAssessmentsUpdate>>, {id: number;data: NonReadonly<AssessmentCreate>}> = (props) => {
          const {id,data} = props ?? {};

          return  evaluationAssessmentsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationAssessmentsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsUpdate>>>
    export type EvaluationAssessmentsUpdateMutationBody = NonReadonly<AssessmentCreate>
    export type EvaluationAssessmentsUpdateMutationError = unknown

    export const useEvaluationAssessmentsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsUpdate>>, TError,{id: number;data: NonReadonly<AssessmentCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationAssessmentsUpdate>>,
        TError,
        {id: number;data: NonReadonly<AssessmentCreate>},
        TContext
      > => {

      const mutationOptions = getEvaluationAssessmentsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for assessments.
 */
export const evaluationAssessmentsPartialUpdate = (
    id: number,
    patchedAssessmentCreate: NonReadonly<PatchedAssessmentCreate>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<AssessmentCreate>(
      {url: `/api/evaluation/assessments/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedAssessmentCreate
    },
      options);
    }
  


export const getEvaluationAssessmentsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAssessmentCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAssessmentCreate>}, TContext> => {

const mutationKey = ['evaluationAssessmentsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationAssessmentsPartialUpdate>>, {id: number;data: NonReadonly<PatchedAssessmentCreate>}> = (props) => {
          const {id,data} = props ?? {};

          return  evaluationAssessmentsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationAssessmentsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsPartialUpdate>>>
    export type EvaluationAssessmentsPartialUpdateMutationBody = NonReadonly<PatchedAssessmentCreate>
    export type EvaluationAssessmentsPartialUpdateMutationError = unknown

    export const useEvaluationAssessmentsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedAssessmentCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationAssessmentsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedAssessmentCreate>},
        TContext
      > => {

      const mutationOptions = getEvaluationAssessmentsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for assessments.
 */
export const evaluationAssessmentsDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/evaluation/assessments/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getEvaluationAssessmentsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['evaluationAssessmentsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationAssessmentsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  evaluationAssessmentsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationAssessmentsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsDestroy>>>
    
    export type EvaluationAssessmentsDestroyMutationError = unknown

    export const useEvaluationAssessmentsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationAssessmentsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationAssessmentsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getEvaluationAssessmentsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all grades for this assessment.
 */
export const evaluationAssessmentsGradesRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Assessment>(
      {url: `/api/evaluation/assessments/${id}/grades/`, method: 'GET', signal
    },
      options);
    }
  



export const getEvaluationAssessmentsGradesRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/evaluation/assessments/${id}/grades/`
    ] as const;
    }

export const getEvaluationAssessmentsGradesRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/evaluation/assessments/${id}/grades/`
    ] as const;
    }

    
export const getEvaluationAssessmentsGradesRetrieveInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentsGradesRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>> = ({ signal }) => evaluationAssessmentsGradesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentsGradesRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>>
export type EvaluationAssessmentsGradesRetrieveInfiniteQueryError = unknown


export function useEvaluationAssessmentsGradesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsGradesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsGradesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentsGradesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentsGradesRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationAssessmentsGradesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentsGradesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>> = ({ signal }) => evaluationAssessmentsGradesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentsGradesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>>
export type EvaluationAssessmentsGradesRetrieveQueryError = unknown


export function useEvaluationAssessmentsGradesRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsGradesRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsGradesRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentsGradesRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentsGradesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Get statistics for this assessment.
 */
export const evaluationAssessmentsStatisticsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Assessment>(
      {url: `/api/evaluation/assessments/${id}/statistics/`, method: 'GET', signal
    },
      options);
    }
  



export const getEvaluationAssessmentsStatisticsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/evaluation/assessments/${id}/statistics/`
    ] as const;
    }

export const getEvaluationAssessmentsStatisticsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/evaluation/assessments/${id}/statistics/`
    ] as const;
    }

    
export const getEvaluationAssessmentsStatisticsRetrieveInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentsStatisticsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>> = ({ signal }) => evaluationAssessmentsStatisticsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentsStatisticsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>>
export type EvaluationAssessmentsStatisticsRetrieveInfiniteQueryError = unknown


export function useEvaluationAssessmentsStatisticsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsStatisticsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsStatisticsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentsStatisticsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentsStatisticsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationAssessmentsStatisticsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationAssessmentsStatisticsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>> = ({ signal }) => evaluationAssessmentsStatisticsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationAssessmentsStatisticsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>>
export type EvaluationAssessmentsStatisticsRetrieveQueryError = unknown


export function useEvaluationAssessmentsStatisticsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsStatisticsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationAssessmentsStatisticsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationAssessmentsStatisticsRetrieve<TData = Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationAssessmentsStatisticsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationAssessmentsStatisticsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for course enrollments.
 */
export const evaluationEnrollmentsList = (
    params?: EvaluationEnrollmentsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedCourseEnrollmentList>(
      {url: `/api/evaluation/enrollments/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getEvaluationEnrollmentsListInfiniteQueryKey = (params?: EvaluationEnrollmentsListParams,) => {
    return [
    'infinate', `/api/evaluation/enrollments/`, ...(params ? [params]: [])
    ] as const;
    }

export const getEvaluationEnrollmentsListQueryKey = (params?: EvaluationEnrollmentsListParams,) => {
    return [
    `/api/evaluation/enrollments/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getEvaluationEnrollmentsListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, EvaluationEnrollmentsListParams['page']>, TError = unknown>(params?: EvaluationEnrollmentsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData, QueryKey, EvaluationEnrollmentsListParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationEnrollmentsListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, QueryKey, EvaluationEnrollmentsListParams['page']> = ({ signal, pageParam }) => evaluationEnrollmentsList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData, QueryKey, EvaluationEnrollmentsListParams['page']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationEnrollmentsListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationEnrollmentsList>>>
export type EvaluationEnrollmentsListInfiniteQueryError = unknown


export function useEvaluationEnrollmentsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, EvaluationEnrollmentsListParams['page']>, TError = unknown>(
 params: undefined |  EvaluationEnrollmentsListParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData, QueryKey, EvaluationEnrollmentsListParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEnrollmentsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationEnrollmentsList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEnrollmentsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, EvaluationEnrollmentsListParams['page']>, TError = unknown>(
 params?: EvaluationEnrollmentsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData, QueryKey, EvaluationEnrollmentsListParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEnrollmentsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationEnrollmentsList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEnrollmentsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, EvaluationEnrollmentsListParams['page']>, TError = unknown>(
 params?: EvaluationEnrollmentsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData, QueryKey, EvaluationEnrollmentsListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationEnrollmentsListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, EvaluationEnrollmentsListParams['page']>, TError = unknown>(
 params?: EvaluationEnrollmentsListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData, QueryKey, EvaluationEnrollmentsListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationEnrollmentsListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationEnrollmentsListQueryOptions = <TData = Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError = unknown>(params?: EvaluationEnrollmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationEnrollmentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationEnrollmentsList>>> = ({ signal }) => evaluationEnrollmentsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationEnrollmentsListQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationEnrollmentsList>>>
export type EvaluationEnrollmentsListQueryError = unknown


export function useEvaluationEnrollmentsList<TData = Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError = unknown>(
 params: undefined |  EvaluationEnrollmentsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEnrollmentsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationEnrollmentsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEnrollmentsList<TData = Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError = unknown>(
 params?: EvaluationEnrollmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEnrollmentsList>>,
          TError,
          Awaited<ReturnType<typeof evaluationEnrollmentsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEnrollmentsList<TData = Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError = unknown>(
 params?: EvaluationEnrollmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationEnrollmentsList<TData = Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError = unknown>(
 params?: EvaluationEnrollmentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationEnrollmentsListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for course enrollments.
 */
export const evaluationEnrollmentsCreate = (
    courseEnrollment: NonReadonly<CourseEnrollment>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CourseEnrollment>(
      {url: `/api/evaluation/enrollments/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: courseEnrollment, signal
    },
      options);
    }
  


export const getEvaluationEnrollmentsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsCreate>>, TError,{data: NonReadonly<CourseEnrollment>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsCreate>>, TError,{data: NonReadonly<CourseEnrollment>}, TContext> => {

const mutationKey = ['evaluationEnrollmentsCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationEnrollmentsCreate>>, {data: NonReadonly<CourseEnrollment>}> = (props) => {
          const {data} = props ?? {};

          return  evaluationEnrollmentsCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationEnrollmentsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationEnrollmentsCreate>>>
    export type EvaluationEnrollmentsCreateMutationBody = NonReadonly<CourseEnrollment>
    export type EvaluationEnrollmentsCreateMutationError = unknown

    export const useEvaluationEnrollmentsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsCreate>>, TError,{data: NonReadonly<CourseEnrollment>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationEnrollmentsCreate>>,
        TError,
        {data: NonReadonly<CourseEnrollment>},
        TContext
      > => {

      const mutationOptions = getEvaluationEnrollmentsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for course enrollments.
 */
export const evaluationEnrollmentsRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CourseEnrollment>(
      {url: `/api/evaluation/enrollments/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getEvaluationEnrollmentsRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/evaluation/enrollments/${id}/`
    ] as const;
    }

export const getEvaluationEnrollmentsRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/evaluation/enrollments/${id}/`
    ] as const;
    }

    
export const getEvaluationEnrollmentsRetrieveInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationEnrollmentsRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>> = ({ signal }) => evaluationEnrollmentsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationEnrollmentsRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>>
export type EvaluationEnrollmentsRetrieveInfiniteQueryError = unknown


export function useEvaluationEnrollmentsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEnrollmentsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEnrollmentsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationEnrollmentsRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationEnrollmentsRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationEnrollmentsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationEnrollmentsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>> = ({ signal }) => evaluationEnrollmentsRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationEnrollmentsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>>
export type EvaluationEnrollmentsRetrieveQueryError = unknown


export function useEvaluationEnrollmentsRetrieve<TData = Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEnrollmentsRetrieve<TData = Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEnrollmentsRetrieve<TData = Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationEnrollmentsRetrieve<TData = Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEnrollmentsRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationEnrollmentsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for course enrollments.
 */
export const evaluationEnrollmentsUpdate = (
    id: number,
    courseEnrollment: NonReadonly<CourseEnrollment>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CourseEnrollment>(
      {url: `/api/evaluation/enrollments/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: courseEnrollment
    },
      options);
    }
  


export const getEvaluationEnrollmentsUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsUpdate>>, TError,{id: number;data: NonReadonly<CourseEnrollment>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsUpdate>>, TError,{id: number;data: NonReadonly<CourseEnrollment>}, TContext> => {

const mutationKey = ['evaluationEnrollmentsUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationEnrollmentsUpdate>>, {id: number;data: NonReadonly<CourseEnrollment>}> = (props) => {
          const {id,data} = props ?? {};

          return  evaluationEnrollmentsUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationEnrollmentsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationEnrollmentsUpdate>>>
    export type EvaluationEnrollmentsUpdateMutationBody = NonReadonly<CourseEnrollment>
    export type EvaluationEnrollmentsUpdateMutationError = unknown

    export const useEvaluationEnrollmentsUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsUpdate>>, TError,{id: number;data: NonReadonly<CourseEnrollment>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationEnrollmentsUpdate>>,
        TError,
        {id: number;data: NonReadonly<CourseEnrollment>},
        TContext
      > => {

      const mutationOptions = getEvaluationEnrollmentsUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for course enrollments.
 */
export const evaluationEnrollmentsPartialUpdate = (
    id: number,
    patchedCourseEnrollment: NonReadonly<PatchedCourseEnrollment>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CourseEnrollment>(
      {url: `/api/evaluation/enrollments/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedCourseEnrollment
    },
      options);
    }
  


export const getEvaluationEnrollmentsPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedCourseEnrollment>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedCourseEnrollment>}, TContext> => {

const mutationKey = ['evaluationEnrollmentsPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationEnrollmentsPartialUpdate>>, {id: number;data: NonReadonly<PatchedCourseEnrollment>}> = (props) => {
          const {id,data} = props ?? {};

          return  evaluationEnrollmentsPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationEnrollmentsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationEnrollmentsPartialUpdate>>>
    export type EvaluationEnrollmentsPartialUpdateMutationBody = NonReadonly<PatchedCourseEnrollment>
    export type EvaluationEnrollmentsPartialUpdateMutationError = unknown

    export const useEvaluationEnrollmentsPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedCourseEnrollment>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationEnrollmentsPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedCourseEnrollment>},
        TContext
      > => {

      const mutationOptions = getEvaluationEnrollmentsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for course enrollments.
 */
export const evaluationEnrollmentsDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/evaluation/enrollments/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getEvaluationEnrollmentsDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['evaluationEnrollmentsDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationEnrollmentsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  evaluationEnrollmentsDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationEnrollmentsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationEnrollmentsDestroy>>>
    
    export type EvaluationEnrollmentsDestroyMutationError = unknown

    export const useEvaluationEnrollmentsDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationEnrollmentsDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getEvaluationEnrollmentsDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Enroll multiple students in a course.
 */
export const evaluationEnrollmentsBulkEnrollCreate = (
    courseEnrollment: NonReadonly<CourseEnrollment>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CourseEnrollment>(
      {url: `/api/evaluation/enrollments/bulk_enroll/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: courseEnrollment, signal
    },
      options);
    }
  


export const getEvaluationEnrollmentsBulkEnrollCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsBulkEnrollCreate>>, TError,{data: NonReadonly<CourseEnrollment>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsBulkEnrollCreate>>, TError,{data: NonReadonly<CourseEnrollment>}, TContext> => {

const mutationKey = ['evaluationEnrollmentsBulkEnrollCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationEnrollmentsBulkEnrollCreate>>, {data: NonReadonly<CourseEnrollment>}> = (props) => {
          const {data} = props ?? {};

          return  evaluationEnrollmentsBulkEnrollCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationEnrollmentsBulkEnrollCreateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationEnrollmentsBulkEnrollCreate>>>
    export type EvaluationEnrollmentsBulkEnrollCreateMutationBody = NonReadonly<CourseEnrollment>
    export type EvaluationEnrollmentsBulkEnrollCreateMutationError = unknown

    export const useEvaluationEnrollmentsBulkEnrollCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEnrollmentsBulkEnrollCreate>>, TError,{data: NonReadonly<CourseEnrollment>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationEnrollmentsBulkEnrollCreate>>,
        TError,
        {data: NonReadonly<CourseEnrollment>},
        TContext
      > => {

      const mutationOptions = getEvaluationEnrollmentsBulkEnrollCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List all student grades (evaluations).
 */
export const evaluationEvaluationList = (
    params?: EvaluationEvaluationListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedStudentGradeList>(
      {url: `/api/evaluation/evaluation/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getEvaluationEvaluationListInfiniteQueryKey = (params?: EvaluationEvaluationListParams,) => {
    return [
    'infinate', `/api/evaluation/evaluation/`, ...(params ? [params]: [])
    ] as const;
    }

export const getEvaluationEvaluationListQueryKey = (params?: EvaluationEvaluationListParams,) => {
    return [
    `/api/evaluation/evaluation/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getEvaluationEvaluationListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationList>>, EvaluationEvaluationListParams['page']>, TError = unknown>(params?: EvaluationEvaluationListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData, QueryKey, EvaluationEvaluationListParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationEvaluationListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationEvaluationList>>, QueryKey, EvaluationEvaluationListParams['page']> = ({ signal, pageParam }) => evaluationEvaluationList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData, QueryKey, EvaluationEvaluationListParams['page']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationEvaluationListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationEvaluationList>>>
export type EvaluationEvaluationListInfiniteQueryError = unknown


export function useEvaluationEvaluationListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationList>>, EvaluationEvaluationListParams['page']>, TError = unknown>(
 params: undefined |  EvaluationEvaluationListParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData, QueryKey, EvaluationEvaluationListParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEvaluationList>>,
          TError,
          Awaited<ReturnType<typeof evaluationEvaluationList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEvaluationListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationList>>, EvaluationEvaluationListParams['page']>, TError = unknown>(
 params?: EvaluationEvaluationListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData, QueryKey, EvaluationEvaluationListParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEvaluationList>>,
          TError,
          Awaited<ReturnType<typeof evaluationEvaluationList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEvaluationListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationList>>, EvaluationEvaluationListParams['page']>, TError = unknown>(
 params?: EvaluationEvaluationListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData, QueryKey, EvaluationEvaluationListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationEvaluationListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationList>>, EvaluationEvaluationListParams['page']>, TError = unknown>(
 params?: EvaluationEvaluationListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData, QueryKey, EvaluationEvaluationListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationEvaluationListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationEvaluationListQueryOptions = <TData = Awaited<ReturnType<typeof evaluationEvaluationList>>, TError = unknown>(params?: EvaluationEvaluationListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationEvaluationListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationEvaluationList>>> = ({ signal }) => evaluationEvaluationList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationEvaluationListQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationEvaluationList>>>
export type EvaluationEvaluationListQueryError = unknown


export function useEvaluationEvaluationList<TData = Awaited<ReturnType<typeof evaluationEvaluationList>>, TError = unknown>(
 params: undefined |  EvaluationEvaluationListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEvaluationList>>,
          TError,
          Awaited<ReturnType<typeof evaluationEvaluationList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEvaluationList<TData = Awaited<ReturnType<typeof evaluationEvaluationList>>, TError = unknown>(
 params?: EvaluationEvaluationListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEvaluationList>>,
          TError,
          Awaited<ReturnType<typeof evaluationEvaluationList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEvaluationList<TData = Awaited<ReturnType<typeof evaluationEvaluationList>>, TError = unknown>(
 params?: EvaluationEvaluationListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationEvaluationList<TData = Awaited<ReturnType<typeof evaluationEvaluationList>>, TError = unknown>(
 params?: EvaluationEvaluationListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationEvaluationListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Retrieve a single student grade by PK.
 */
export const evaluationEvaluationRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StudentGrade>(
      {url: `/api/evaluation/evaluation/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getEvaluationEvaluationRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/evaluation/evaluation/${id}/`
    ] as const;
    }

export const getEvaluationEvaluationRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/evaluation/evaluation/${id}/`
    ] as const;
    }

    
export const getEvaluationEvaluationRetrieveInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationEvaluationRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>> = ({ signal }) => evaluationEvaluationRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationEvaluationRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>>
export type EvaluationEvaluationRetrieveInfiniteQueryError = unknown


export function useEvaluationEvaluationRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEvaluationRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEvaluationRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationEvaluationRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationEvaluationRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationEvaluationRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationEvaluationRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>> = ({ signal }) => evaluationEvaluationRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationEvaluationRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>>
export type EvaluationEvaluationRetrieveQueryError = unknown


export function useEvaluationEvaluationRetrieve<TData = Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEvaluationRetrieve<TData = Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationEvaluationRetrieve<TData = Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationEvaluationRetrieve<TData = Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationEvaluationRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationEvaluationRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Create a student grade (evaluation).
 */
export const evaluationEvaluationCreateCreate = (
    studentGradeCreate: NonReadonly<StudentGradeCreate>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StudentGradeCreate>(
      {url: `/api/evaluation/evaluation/create/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: studentGradeCreate, signal
    },
      options);
    }
  


export const getEvaluationEvaluationCreateCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEvaluationCreateCreate>>, TError,{data: NonReadonly<StudentGradeCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationEvaluationCreateCreate>>, TError,{data: NonReadonly<StudentGradeCreate>}, TContext> => {

const mutationKey = ['evaluationEvaluationCreateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationEvaluationCreateCreate>>, {data: NonReadonly<StudentGradeCreate>}> = (props) => {
          const {data} = props ?? {};

          return  evaluationEvaluationCreateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationEvaluationCreateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationEvaluationCreateCreate>>>
    export type EvaluationEvaluationCreateCreateMutationBody = NonReadonly<StudentGradeCreate>
    export type EvaluationEvaluationCreateCreateMutationError = unknown

    export const useEvaluationEvaluationCreateCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationEvaluationCreateCreate>>, TError,{data: NonReadonly<StudentGradeCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationEvaluationCreateCreate>>,
        TError,
        {data: NonReadonly<StudentGradeCreate>},
        TContext
      > => {

      const mutationOptions = getEvaluationEvaluationCreateCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for student grades.
 */
export const evaluationGradesList = (
    params?: EvaluationGradesListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PaginatedStudentGradeList>(
      {url: `/api/evaluation/grades/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getEvaluationGradesListInfiniteQueryKey = (params?: EvaluationGradesListParams,) => {
    return [
    'infinate', `/api/evaluation/grades/`, ...(params ? [params]: [])
    ] as const;
    }

export const getEvaluationGradesListQueryKey = (params?: EvaluationGradesListParams,) => {
    return [
    `/api/evaluation/grades/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getEvaluationGradesListInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesList>>, EvaluationGradesListParams['page']>, TError = unknown>(params?: EvaluationGradesListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData, QueryKey, EvaluationGradesListParams['page']>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationGradesListInfiniteQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationGradesList>>, QueryKey, EvaluationGradesListParams['page']> = ({ signal, pageParam }) => evaluationGradesList({...params, 'page': pageParam || params?.['page']}, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData, QueryKey, EvaluationGradesListParams['page']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationGradesListInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesList>>>
export type EvaluationGradesListInfiniteQueryError = unknown


export function useEvaluationGradesListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesList>>, EvaluationGradesListParams['page']>, TError = unknown>(
 params: undefined |  EvaluationGradesListParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData, QueryKey, EvaluationGradesListParams['page']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesList>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesList>>, EvaluationGradesListParams['page']>, TError = unknown>(
 params?: EvaluationGradesListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData, QueryKey, EvaluationGradesListParams['page']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesList>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesList>>, QueryKey
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesList>>, EvaluationGradesListParams['page']>, TError = unknown>(
 params?: EvaluationGradesListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData, QueryKey, EvaluationGradesListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationGradesListInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesList>>, EvaluationGradesListParams['page']>, TError = unknown>(
 params?: EvaluationGradesListParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData, QueryKey, EvaluationGradesListParams['page']>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationGradesListInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationGradesListQueryOptions = <TData = Awaited<ReturnType<typeof evaluationGradesList>>, TError = unknown>(params?: EvaluationGradesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationGradesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationGradesList>>> = ({ signal }) => evaluationGradesList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationGradesListQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesList>>>
export type EvaluationGradesListQueryError = unknown


export function useEvaluationGradesList<TData = Awaited<ReturnType<typeof evaluationGradesList>>, TError = unknown>(
 params: undefined |  EvaluationGradesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesList>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesList<TData = Awaited<ReturnType<typeof evaluationGradesList>>, TError = unknown>(
 params?: EvaluationGradesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesList>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesList<TData = Awaited<ReturnType<typeof evaluationGradesList>>, TError = unknown>(
 params?: EvaluationGradesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationGradesList<TData = Awaited<ReturnType<typeof evaluationGradesList>>, TError = unknown>(
 params?: EvaluationGradesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationGradesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for student grades.
 */
export const evaluationGradesCreate = (
    studentGradeCreate: NonReadonly<StudentGradeCreate>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StudentGradeCreate>(
      {url: `/api/evaluation/grades/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: studentGradeCreate, signal
    },
      options);
    }
  


export const getEvaluationGradesCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesCreate>>, TError,{data: NonReadonly<StudentGradeCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesCreate>>, TError,{data: NonReadonly<StudentGradeCreate>}, TContext> => {

const mutationKey = ['evaluationGradesCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationGradesCreate>>, {data: NonReadonly<StudentGradeCreate>}> = (props) => {
          const {data} = props ?? {};

          return  evaluationGradesCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationGradesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesCreate>>>
    export type EvaluationGradesCreateMutationBody = NonReadonly<StudentGradeCreate>
    export type EvaluationGradesCreateMutationError = unknown

    export const useEvaluationGradesCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesCreate>>, TError,{data: NonReadonly<StudentGradeCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationGradesCreate>>,
        TError,
        {data: NonReadonly<StudentGradeCreate>},
        TContext
      > => {

      const mutationOptions = getEvaluationGradesCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for student grades.
 */
export const evaluationGradesRetrieve = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StudentGrade>(
      {url: `/api/evaluation/grades/${id}/`, method: 'GET', signal
    },
      options);
    }
  



export const getEvaluationGradesRetrieveInfiniteQueryKey = (id?: number,) => {
    return [
    'infinate', `/api/evaluation/grades/${id}/`
    ] as const;
    }

export const getEvaluationGradesRetrieveQueryKey = (id?: number,) => {
    return [
    `/api/evaluation/grades/${id}/`
    ] as const;
    }

    
export const getEvaluationGradesRetrieveInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesRetrieve>>>, TError = unknown>(id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationGradesRetrieveInfiniteQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationGradesRetrieve>>> = ({ signal }) => evaluationGradesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationGradesRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesRetrieve>>>
export type EvaluationGradesRetrieveInfiniteQueryError = unknown


export function useEvaluationGradesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesRetrieve>>>, TError = unknown>(
 id: number, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationGradesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesRetrieve>>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationGradesRetrieveInfiniteQueryOptions(id,options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationGradesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationGradesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationGradesRetrieve>>> = ({ signal }) => evaluationGradesRetrieve(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationGradesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesRetrieve>>>
export type EvaluationGradesRetrieveQueryError = unknown


export function useEvaluationGradesRetrieve<TData = Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesRetrieve<TData = Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesRetrieve<TData = Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationGradesRetrieve<TData = Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationGradesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * CRUD operations for student grades.
 */
export const evaluationGradesUpdate = (
    id: number,
    studentGradeCreate: NonReadonly<StudentGradeCreate>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<StudentGradeCreate>(
      {url: `/api/evaluation/grades/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: studentGradeCreate
    },
      options);
    }
  


export const getEvaluationGradesUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesUpdate>>, TError,{id: number;data: NonReadonly<StudentGradeCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesUpdate>>, TError,{id: number;data: NonReadonly<StudentGradeCreate>}, TContext> => {

const mutationKey = ['evaluationGradesUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationGradesUpdate>>, {id: number;data: NonReadonly<StudentGradeCreate>}> = (props) => {
          const {id,data} = props ?? {};

          return  evaluationGradesUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationGradesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesUpdate>>>
    export type EvaluationGradesUpdateMutationBody = NonReadonly<StudentGradeCreate>
    export type EvaluationGradesUpdateMutationError = unknown

    export const useEvaluationGradesUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesUpdate>>, TError,{id: number;data: NonReadonly<StudentGradeCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationGradesUpdate>>,
        TError,
        {id: number;data: NonReadonly<StudentGradeCreate>},
        TContext
      > => {

      const mutationOptions = getEvaluationGradesUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for student grades.
 */
export const evaluationGradesPartialUpdate = (
    id: number,
    patchedStudentGradeCreate: NonReadonly<PatchedStudentGradeCreate>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<StudentGradeCreate>(
      {url: `/api/evaluation/grades/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchedStudentGradeCreate
    },
      options);
    }
  


export const getEvaluationGradesPartialUpdateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedStudentGradeCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedStudentGradeCreate>}, TContext> => {

const mutationKey = ['evaluationGradesPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationGradesPartialUpdate>>, {id: number;data: NonReadonly<PatchedStudentGradeCreate>}> = (props) => {
          const {id,data} = props ?? {};

          return  evaluationGradesPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationGradesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesPartialUpdate>>>
    export type EvaluationGradesPartialUpdateMutationBody = NonReadonly<PatchedStudentGradeCreate>
    export type EvaluationGradesPartialUpdateMutationError = unknown

    export const useEvaluationGradesPartialUpdate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesPartialUpdate>>, TError,{id: number;data: NonReadonly<PatchedStudentGradeCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationGradesPartialUpdate>>,
        TError,
        {id: number;data: NonReadonly<PatchedStudentGradeCreate>},
        TContext
      > => {

      const mutationOptions = getEvaluationGradesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * CRUD operations for student grades.
 */
export const evaluationGradesDestroy = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/evaluation/grades/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getEvaluationGradesDestroyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesDestroy>>, TError,{id: number}, TContext> => {

const mutationKey = ['evaluationGradesDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluationGradesDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  evaluationGradesDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluationGradesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesDestroy>>>
    
    export type EvaluationGradesDestroyMutationError = unknown

    export const useEvaluationGradesDestroy = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluationGradesDestroy>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof evaluationGradesDestroy>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getEvaluationGradesDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Calculate weighted course averages based on assessment grades and weights.
This is used for lecturer analytics and charts.

Query Parameters:
- student: Student ID (optional) - for specific student
- course: Course ID (optional) - for specific course

Returns:
- List of courses with calculated weighted average percentage based on grades

Example: /api/evaluation/grades/course_averages/?student=1
Example: /api/evaluation/grades/course_averages/?course=5
 */
export const evaluationGradesCourseAveragesRetrieve = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<StudentGrade>(
      {url: `/api/evaluation/grades/course_averages/`, method: 'GET', signal
    },
      options);
    }
  



export const getEvaluationGradesCourseAveragesRetrieveInfiniteQueryKey = () => {
    return [
    'infinate', `/api/evaluation/grades/course_averages/`
    ] as const;
    }

export const getEvaluationGradesCourseAveragesRetrieveQueryKey = () => {
    return [
    `/api/evaluation/grades/course_averages/`
    ] as const;
    }

    
export const getEvaluationGradesCourseAveragesRetrieveInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>>, TError = unknown>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationGradesCourseAveragesRetrieveInfiniteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>> = ({ signal }) => evaluationGradesCourseAveragesRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationGradesCourseAveragesRetrieveInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>>
export type EvaluationGradesCourseAveragesRetrieveInfiniteQueryError = unknown


export function useEvaluationGradesCourseAveragesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>>, TError = unknown>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesCourseAveragesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesCourseAveragesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationGradesCourseAveragesRetrieveInfinite<TData = InfiniteData<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>>, TError = unknown>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationGradesCourseAveragesRetrieveInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions, queryClient) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getEvaluationGradesCourseAveragesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEvaluationGradesCourseAveragesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>> = ({ signal }) => evaluationGradesCourseAveragesRetrieve(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EvaluationGradesCourseAveragesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>>
export type EvaluationGradesCourseAveragesRetrieveQueryError = unknown


export function useEvaluationGradesCourseAveragesRetrieve<TData = Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesCourseAveragesRetrieve<TData = Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>,
          TError,
          Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useEvaluationGradesCourseAveragesRetrieve<TData = Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useEvaluationGradesCourseAveragesRetrieve<TData = Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof evaluationGradesCourseAveragesRetrieve>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEvaluationGradesCourseAveragesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



